import "./IERC721Collectible.sol";

/**
 * @title IERC721Exchangeable
 * @dev An ERC-721 Non-Fungible Token where each token is one of an enumerable
 * set of "types." Each token type has with a value (that may or may not correspond to
 * purchase / sale price; e.g. it may be "mining power"). The total value owned
 * by an address may be queried, as well as the number of types owned and list of
 * tokens by type. Types are enumerated 0...n-1.
 */
pragma solidity ^0.8.0;
interface IERC721TypeExchangeable {
    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * @return tokenId The created tokenID
     */
    function mint(address to, uint256 tokenType) external returns (uint256 tokenId);

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * @return tokenIds The created tokenIDs, in the same order as their specified types.
     */
    function massMint(address to, uint256[] calldata tokenTypes) external returns (uint256[] memory tokenIds);

    /**
     * @dev Burns the indicated token from `from`'s collection. Only allowed if the
     * caller has approval to access this token its owner's collection (and `from`
     * is the owner of the token).
     */
    function burnFrom(address from, uint256 tokenId) external;

    /**
     * @dev Burns the indicated token from `from`'s collection. Only allowed if the
     * caller has approval to access this token its owner's collection (and `from`
     * is the owner of the token).
     */
    function massBurnFrom(address from, uint256[] calldata tokenIds) external;

    /**
     * @dev Mass transfers tokens (listed as IDs) between the indicated addresses.
     * The caller must have access to the tokens, which must all be owned by the
     * indicated address. This is not a _safe_ transfer; tokens may be trapped
     * in a contract which can't access them. For safe transfers, move them
     * one at a time.
     */
    function massTransferFrom(address from, address to, uint256[] calldata tokenId) external;

    /**
     * @dev A batch-operation: burns the indicated tokens from the collection of
     * `owner` (the caller must have approval to do this for all tokens), and
     * mints to them the token type(s) indicated. The caller must have minting
     * privileges and transfer access to all listed tokens (which must be owned
     * by the indicated account).
     * @return tokenIds The created tokenIDs, in the same order as their specified types.
     */
    function exchange(address owner, uint256[] calldata burnTokenIds, uint256[] calldata tokenTypes) external returns (uint256[] memory tokenIds);
}
